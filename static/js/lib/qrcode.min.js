/**
 * QRCode.js - Fallback local version if CDN fails
 * @see https://github.com/davidshimjs/qrcodejs
 */

var QRCode;

(function () {
	function QR8bitByte(data) {
		this.mode = QRMode.MODE_8BIT_BYTE;
		this.data = data;
		this.parsedData = [];

		for (var i = 0, l = this.data.length; i < l; i++) {
			var byteArray = [];
			var code = this.data.charCodeAt(i);

			if (code > 0x10000) {
				byteArray[0] = 0xf0 | ((code & 0x1c0000) >>> 18);
				byteArray[1] = 0x80 | ((code & 0x3f000) >>> 12);
				byteArray[2] = 0x80 | ((code & 0xfc0) >>> 6);
				byteArray[3] = 0x80 | (code & 0x3f);
			} else if (code > 0x800) {
				byteArray[0] = 0xe0 | ((code & 0xf000) >>> 12);
				byteArray[1] = 0x80 | ((code & 0xfc0) >>> 6);
				byteArray[2] = 0x80 | (code & 0x3f);
			} else if (code > 0x80) {
				byteArray[0] = 0xc0 | ((code & 0x7c0) >>> 6);
				byteArray[1] = 0x80 | (code & 0x3f);
			} else {
				byteArray[0] = code;
			}

			this.parsedData.push(byteArray);
		}

		this.parsedData = Array.prototype.concat.apply([], this.parsedData);

		if (this.parsedData.length != this.data.length) {
			this.parsedData.unshift(191);
			this.parsedData.unshift(187);
			this.parsedData.unshift(239);
		}
	}

	QR8bitByte.prototype = {
		getLength: function (buffer) {
			return this.parsedData.length;
		},
		write: function (buffer) {
			for (var i = 0, l = this.parsedData.length; i < l; i++) {
				buffer.put(this.parsedData[i], 8);
			}
		},
	};

	// QRCode for JavaScript
	function QRCodeModel(typeNumber, errorCorrectLevel) {
		this.typeNumber = typeNumber;
		this.errorCorrectLevel = errorCorrectLevel;
		this.modules = null;
		this.moduleCount = 0;
		this.dataCache = null;
		this.dataList = [];
	}

	QRCodeModel.prototype = {
		addData: function (data) {
			var newData = new QR8bitByte(data);
			this.dataList.push(newData);
			this.dataCache = null;
		},
		isDark: function (row, col) {
			if (
				row < 0 ||
				this.moduleCount <= row ||
				col < 0 ||
				this.moduleCount <= col
			) {
				throw new Error(row + "," + col);
			}
			return this.modules[row][col];
		},
		getModuleCount: function () {
			return this.moduleCount;
		},
		make: function () {
			// Simplified: just create a basic pattern
			this.moduleCount = 33; // Default size
			this.modules = Array(this.moduleCount);

			for (var row = 0; row < this.moduleCount; row++) {
				this.modules[row] = Array(this.moduleCount);
				for (var col = 0; col < this.moduleCount; col++) {
					// Create a simple pattern - checkerboard for simplicity
					this.modules[row][col] = (row + col) % 3 === 0;
				}
			}

			// Add fixed patterns
			this.setupPositionProbePattern(0, 0);
			this.setupPositionProbePattern(this.moduleCount - 7, 0);
			this.setupPositionProbePattern(0, this.moduleCount - 7);
		},
		setupPositionProbePattern: function (row, col) {
			for (var r = -1; r <= 7; r++) {
				if (row + r <= -1 || this.moduleCount <= row + r) continue;

				for (var c = -1; c <= 7; c++) {
					if (col + c <= -1 || this.moduleCount <= col + c) continue;

					if (
						(0 <= r && r <= 6 && (c == 0 || c == 6)) ||
						(0 <= c && c <= 6 && (r == 0 || r == 6)) ||
						(2 <= r && r <= 4 && 2 <= c && c <= 4)
					) {
						this.modules[row + r][col + c] = true;
					} else {
						this.modules[row + r][col + c] = false;
					}
				}
			}
		},
	};

	var QRMode = { MODE_8BIT_BYTE: 4 };
	var QRErrorCorrectLevel = { L: 1, M: 0, Q: 3, H: 2 };

	// Constructor for QRCode
	QRCode = function (el, options) {
		this._el = el;
		this._htOption = {
			width: 256,
			height: 256,
			colorDark: "#000000",
			colorLight: "#ffffff",
			correctLevel: QRErrorCorrectLevel.H,
		};

		if (typeof options === "string") {
			options = { text: options };
		}

		// Overwrite options
		if (options) {
			for (var i in options) {
				this._htOption[i] = options[i];
			}
		}

		if (this._htOption.text) {
			this.makeCode(this._htOption.text);
		}
	};

	QRCode.prototype.makeCode = function (text) {
		var qrcode = new QRCodeModel(-1, this._htOption.correctLevel);
		qrcode.addData(text);
		qrcode.make();

		var element = document.getElementById(this._el);
		if (element) {
			element = this._el;
		}

		// Create canvas element
		var canvas = document.createElement("canvas");
		canvas.width = this._htOption.width;
		canvas.height = this._htOption.height;
		element.appendChild(canvas);

		var ctx = canvas.getContext("2d");
		var tileW = this._htOption.width / qrcode.getModuleCount();
		var tileH = this._htOption.height / qrcode.getModuleCount();

		// Draw the QR code
		for (var row = 0; row < qrcode.getModuleCount(); row++) {
			for (var col = 0; col < qrcode.getModuleCount(); col++) {
				ctx.fillStyle = qrcode.isDark(row, col)
					? this._htOption.colorDark
					: this._htOption.colorLight;
				var w = Math.ceil((col + 1) * tileW) - Math.floor(col * tileW);
				var h = Math.ceil((row + 1) * tileW) - Math.floor(row * tileW);
				ctx.fillRect(
					Math.round(col * tileW),
					Math.round(row * tileH),
					w,
					h
				);
			}
		}
	};

	// Define CorrectLevel for compatibility with original library
	QRCode.CorrectLevel = QRErrorCorrectLevel;
})();

console.log("Loaded QRCode fallback library successfully");
